

		# show_image("ROI image", ROI_img)

		#Erosion
		# for i in range(0, 3):
		# 	eroded = cv2.erode(img_thresh, None, iterations=i+1)
		# 	cv2.imshow("Eroded {} times".format(i+1), eroded)
		# 	cv2.waitKey(0)

		#Dilation
		# for i in range(0, 3):	
		# 	dilated = cv2.dilate(img_thresh, None, iterations=i+1)
		# 	cv2.imshow("Dilated {} times".format(i+1), dilated)
		
		# 	cv2.waitKey(0)

		# exit()

		# # variables for GrabCut algorithm
		# rectangle_coordinates=(x-offset_minus, y-offset_minus, x + w + offset_plus, y + h + offset_plus)
		# fgModel = np.zeros((1, 65), dtype="float")
		# bgModel = np.zeros((1, 65), dtype="float")
		# mask = np.zeros(gauss_img.shape[:2], dtype="uint8")

		# gauss_img_color = cv2.cvtColor(gauss_img, cv2.COLOR_GRAY2BGR)

		# start = time.time()
		# (mask, bgModel, fgModel) = cv2.grabCut(gauss_img_color, mask, rectangle_coordinates, bgModel, fgModel, iterCount=5, mode=cv2.GC_INIT_WITH_RECT)
		# end = time.time()
		# print("[INFO] applying GrabCut took {:.2f} seconds".format(end - start) + " for " + full_path)

		# values = (
		# 	("Definite Background", cv2.GC_BGD),
		# 	("Probable Background", cv2.GC_PR_BGD),
		# 	("Definite Foreground", cv2.GC_FGD),
		# 	("Probable Foreground", cv2.GC_PR_FGD),
		# )
		# # loop over the possible GrabCut mask values
		# for (name, value) in values:
		# 	# construct a mask that for the current value
		# 	# print("[INFO] showing mask for '{}'".format(name))
		# 	valueMask = (mask == value).astype("uint8") * 255
		# 	# # display the mask so we can visualize it
		# 	# cv2.imshow(name, valueMask)
		# 	# cv2.waitKey(0)

		# # we'll set all definite background and probable background pixels
		# # to 0 while definite foreground and probable foreground pixels are
		# # set to 1
		# outputMask = np.where((mask == cv2.GC_BGD) | (mask == cv2.GC_PR_BGD), 0, 1)
		# # scale the mask from the range [0, 1] to [0, 255]
		# outputMask = (outputMask * 255).astype("uint8")
		# # apply a bitwise AND to the image using our mask generated by
		# # GrabCut to generate our final output image
		# output = cv2.bitwise_and(gauss_img, gauss_img, mask=outputMask)
		# output = output[y - offset_minus : y - offset_minus + h + offset_plus, x - offset_minus : x - offset_minus + w + offset_plus]


		# # show the input image followed by the mask and output generated by
		# # GrabCut and bitwise masking
		# # cv2.imshow("Input", gauss_img)
		# # cv2.imshow("GrabCut Mask", outputMask)
		# cv2.imshow("GrabCut Output", output)
		# cv2.waitKey(0)


		# # Save ROI image
		# cv2.imwrite('test.jpg', ROI)
		# cv2.imwrite('out_melanoma.jpg', output)
		
###################	FROM ASSYMETRY	###################

###IT'S OK
# ratio_array = []
# for i in range(100):
# 	random_pixel = find_random_contour_pixel(contour)
# 	# print("Random pixel: ", random_pixel)
# 	second_horizontal_pixel = find_second_horizontal_pixel(random_pixel, contour)
# 	# print("Second horizontal pixel: ", second_horizontal_pixel)
# 	ratio = find_length_ratio(x_vertical_line, random_pixel, second_horizontal_pixel)
# 	# print("Length ratio: ", ratio)

# 	ratio_array.append(ratio)
# a_vertical = analyze_ratio_array(ratio_array)
# A = A - a_vertical
# print("[INFO] Ma after vertical check: ", A)

# ratio_array = []
# for i in range(100):
# 	random_pixel = find_random_contour_pixel(contour)
# 	second_vertical_pixel = find_second_vertical_pixel(random_pixel, contour)
# 	ratio = find_length_ratio(y_horizontal_line, random_pixel, second_vertical_pixel)
# 	ratio_array.append(ratio)
# a_horizontal = analyze_ratio_array(ratio_array)
# A = A - a_horizontal
# print("[INFO] Ma after horizontal check: ", A)

# print("[INFO] Ma after vertical and horizontal check: ", A*1.3)

# def find_line(contour, center):
# 	p1 = center
# 	p2 = contour[2][0]
# 	a = (p1[1]-p2[1])/(p1[0]-p2[0]) 	# a = y1 - y2 / x1 - x2
# 	b = p1[1] - a * p1[0] 				# b = y - ax	
# 	return a, b

# def find_perpendicular_line(a, b, pixel):
# 	a = 0 								# horizontal line, a=0
# 	# a = -1 / a
# 	b = pixel[1] - a * pixel[0]
# 	return a, b

# def find_second_pixel(a, b, pixel, contour):
# 	second_pixel = [0, 0]
# 	for p in contour:		
# 		x = p[0][0]
# 		y = p[0][1]
# 		val = a * x + b - y
# 		if val == 0:
# 			print(p[0])
# 	print("\n")
# 	return second_pixel

# def find_second_horizontal_pixel(pixel, contour):
# 	x = pixel[0]
# 	y = pixel[1]
# 	for p in contour:
# 		px = p[0][0]
# 		py = p[0][1]
# 		if py == y:
# 			if px != x:
# 				second_horizontal_pixel = p[0]	
# 	return second_horizontal_pixel

# def find_second_vertical_pixel(pixel, contour):
# 	x = pixel[0]
# 	y = pixel[1]
# 	for p in contour:
# 		px = p[0][0]
# 		py = p[0][1]
# 		if px == x:
# 			if py != y:
# 				second_horizontal_pixel = p[0]	
# 	return second_horizontal_pixel

# def find_random_contour_pixel(contour):
# 	rand_i = randrange(len(contour))
# 	rand_pixel = contour[rand_i][0]
# 	return rand_pixel


###################	END FROM ASSYMETRY	###################